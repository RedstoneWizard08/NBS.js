{"code":"import { BufferWriter } from \"../../util/util\";\r\n/**\r\n * Generate and return an ArrayBuffer from a song.\r\n *\r\n * @param song Song to parse from\r\n * @return Generated ArrayBuffer\r\n * Returns an empty ArrayBuffer if an error occurred\r\n */\r\nexport default function toArrayBuffer(song) {\r\n    // Dry run to get target size\r\n    const size = write(song, 0, true).nextByte;\r\n    // Create the actual buffer\r\n    return write(song, size).buffer;\r\n}\r\nfunction write(song, size, dry = false) {\r\n    const writer = new BufferWriter(new ArrayBuffer(size), dry);\r\n    try {\r\n        if (song.nbsVersion >= 1) {\r\n            writer.writeShort(0); // Write ONBS spec\r\n            writer.writeByte(song.nbsVersion); // Write NBS version\r\n            writer.writeByte(song.instruments.firstCustomIndex); // First custom instrument index\r\n        }\r\n        if (song.nbsVersion === 0 || song.nbsVersion >= 3) {\r\n            writer.writeShort(song.length); // Write song size\r\n        }\r\n        writer.writeShort(song.layers.length); // Write total amount of layers\r\n        writer.writeString(song.meta.name); // Write song name\r\n        writer.writeString(song.meta.author); // Write song author\r\n        writer.writeString(song.meta.originalAuthor); // Write song original author\r\n        writer.writeString(song.meta.description); // Write song description\r\n        writer.writeShort(song.tempo * 100); // Write song tempo\r\n        writer.writeByte(+song.autosave.enabled); // Write song auto-save status\r\n        writer.writeByte(song.autosave.interval); // Write auto-save interval\r\n        writer.writeByte(song.timeSignature); // Write song time signature\r\n        writer.writeInt(Math.floor(song.stats.minutesSpent)); // Write minutes spent in song\r\n        writer.writeInt(song.stats.leftClicks); // Write left-clicks on song\r\n        writer.writeInt(song.stats.rightClicks); // Write right-clicks on song\r\n        writer.writeInt(song.stats.blocksAdded); // Write total blocks added to song\r\n        writer.writeInt(song.stats.blocksRemoved); // Write total blocks removed from song\r\n        writer.writeString(song.meta.importName); // Write imported MiDi/schematic file name\r\n        if (song.nbsVersion >= 4) {\r\n            writer.writeByte(+song.loop.enabled); // Write loop status\r\n            writer.writeByte(song.loop.totalLoops); // Write maximum loop count\r\n            writer.writeByte(song.loop.startTick); // Write loop start tick\r\n        }\r\n        writer.writeByte(0); // Write end of header\r\n        // Iterate each tick\r\n        let currentTick = -1;\r\n        for (let i = 0; i <= song.length; i++) {\r\n            // Ensure the layer has notes at the tick\r\n            let hasNotes = false;\r\n            for (const layer of song.layers) {\r\n                if (layer.notes[i]) {\r\n                    hasNotes = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!hasNotes) {\r\n                continue;\r\n            }\r\n            // Get amount of ticks to jump\r\n            const jumpTicks = i - currentTick;\r\n            currentTick = i;\r\n            writer.writeShort(jumpTicks); // Write amount of ticks to jump\r\n            // Iterate each layer\r\n            let currentLayer = -1;\r\n            for (let j = 0; j < song.layers.length; j++) {\r\n                const layer = song.layers[j];\r\n                const note = layer.notes[i];\r\n                if (note) {\r\n                    const jumpLayers = j - currentLayer;\r\n                    currentLayer = j;\r\n                    writer.writeShort(jumpLayers); // Write amount of layers to jump\r\n                    writer.writeByte(note.instrument); // Write instrument ID of note\r\n                    writer.writeByte(note.key); // Write key of note\r\n                    if (song.nbsVersion >= 4) {\r\n                        writer.writeByte(note.velocity); // Write velocity of note\r\n                        writer.writeUnsignedByte((note.panning ? note.panning : 0) + 100); // Write panning of note\r\n                        writer.writeShort(note.pitch); // Write pitch of note\r\n                    }\r\n                }\r\n            }\r\n            writer.writeShort(0); // Write end of tick\r\n        }\r\n        writer.writeShort(0); // Write end of notes\r\n        for (const layer of song.layers) {\r\n            writer.writeString(layer.meta.name); // Write layer name\r\n            if (song.nbsVersion >= 4) {\r\n                let val = 0;\r\n                // Layer is locked\r\n                if (layer.isLocked) {\r\n                    val = 1;\r\n                }\r\n                // Layer is solo\r\n                if (layer.isSolo) {\r\n                    val = 2;\r\n                }\r\n                writer.writeByte(val); // Write layer lock status\r\n            }\r\n            writer.writeByte(layer.volume); // Write layer velocity\r\n            if (song.nbsVersion >= 2) {\r\n                writer.writeByte(layer.stereo + 100); // Write layer panning\r\n            }\r\n        }\r\n        writer.writeByte(song.instruments.loaded.length - song.instruments.firstCustomIndex); // Write number of custom instruments\r\n        for (let i = 0; i < song.instruments.loaded.length; i++) {\r\n            const instrument = song.instruments.loaded[i];\r\n            if (!instrument.builtIn) {\r\n                writer.writeString(instrument.meta.name); // Write instrument name\r\n                writer.writeString(instrument.meta.soundFile); // Write instrument filename\r\n                writer.writeByte(instrument.pitch); // Write instrument key\r\n                writer.writeByte(+(instrument.pressKey ?? 0)); // Write press key status\r\n            }\r\n        }\r\n    }\r\n    catch (e) {\r\n        song.errors.push(String(e));\r\n    }\r\n    return writer;\r\n}\r\n","references":["/workspace/NBS.js/src/util/util.ts","/workspace/NBS.js/src/nbs/Song.ts"],"dts":{"name":"/workspace/NBS.js/node_modules/.cache/rollup-plugin-typescript2/placeholder/nbs/file/toArrayBuffer.d.ts","writeByteOrderMark":false,"text":"import Song from \"../Song\";\r\n/**\r\n * Generate and return an ArrayBuffer from a song.\r\n *\r\n * @param song Song to parse from\r\n * @return Generated ArrayBuffer\r\n * Returns an empty ArrayBuffer if an error occurred\r\n */\r\nexport default function toArrayBuffer(song: Song): ArrayBuffer;\r\n"}}
