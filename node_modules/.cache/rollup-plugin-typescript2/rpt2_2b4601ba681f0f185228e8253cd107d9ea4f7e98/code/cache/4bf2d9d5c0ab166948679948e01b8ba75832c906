{"code":"import toArrayBuffer from \"./file/toArrayBuffer\";\r\nimport { getLayerClass } from \"../util/util\";\r\nimport { defaultSongMeta } from \"./interfaces/song/SongMeta\";\r\nimport { defaultSongStats } from \"./interfaces/song/SongStats\";\r\nimport { defaultLoopOptions } from \"./interfaces/song/SongLoopOptions\";\r\nimport { defaultAutosaveOptions } from \"./interfaces/song/SongAutosaveOptions\";\r\nimport { defaultNoteOptions } from \"./interfaces/note/NoteOptions\";\r\nimport SongInstrument from \"./instrument/SongInstrument\";\r\n// TODO:\r\n// - Shrink song when removing notes\r\n// - Create field with loop tick (end of measure)\r\n/**\r\n * Represents a full NBS song file.\r\n *\r\n * Supports reading, writing, and manipulation.\r\n *\r\n * @example\r\n * ```js\r\n * const fs = require(\"fs\");\r\n * const { Song, Note, Instrument } = require(\"@encode42/nbs.js\");\r\n *\r\n * // Create a new song\r\n * const song = new Song();\r\n * song.meta.name = \"Triumph\";\r\n * song.meta.author = \"Encode42\";\r\n * song.tempo = 20;\r\n *\r\n * // Create 3 layers for 3 instruments\r\n * for (let layerCount = 0; layerCount < 3; layerCount++) {\r\n *     const instrument = Instrument.builtIn[layerCount];\r\n *\r\n *     // Create a layer for the instrument\r\n *     const layer = song.createLayer();\r\n *     layer.meta.name = instrument.meta.name;\r\n *\r\n *     // Notes that will be placed\r\n *     const notes = [\r\n *         new Note(instrument, { \"key\": 40 }),\r\n *         new Note(instrument, { \"key\": 45 }),\r\n *         new Note(instrument, { \"key\": 50 }),\r\n *         new Note(instrument, { \"key\": 45 }),\r\n *         new Note(instrument, { \"key\": 57 })\r\n *     ];\r\n *\r\n *     // Place the notes\r\n *     for (let i = 0; i < notes.length; i++) {\r\n *         song.setNote(i * 4, layer, notes[i]);\r\n *     }\r\n * }\r\n *\r\n * // Write the song\r\n * fs.writeFileSync(\"song.nbs\", Buffer.from(song.toArrayBuffer()));\r\n * ```\r\n */\r\nexport default class Song {\r\n    /**\r\n     * Length of the song in ticks.\r\n     */\r\n    length = 0;\r\n    /**\r\n     * Version of NBS the song has been saved to.\r\n     *\r\n     * @see https://opennbs.org/nbs\r\n     */\r\n    nbsVersion = 5;\r\n    /**\r\n     * Meta information for the song.\r\n     *\r\n     * @see {@linkcode SongMeta}\r\n     */\r\n    meta = { ...defaultSongMeta };\r\n    /**\r\n     * Looping options for the song.\r\n     *\r\n     * @see {@linkcode SongLoopOptions}\r\n     */\r\n    loop = { ...defaultLoopOptions };\r\n    /**\r\n     * Auto-save options for the song.\r\n     *\r\n     * @see {@linkcode SongAutosaveOptions}\r\n     */\r\n    autosave = { ...defaultAutosaveOptions };\r\n    /**\r\n     * Statistics for the song.\r\n     *\r\n     * @see {@linkcode SongStats}\r\n     */\r\n    stats = { ...defaultSongStats };\r\n    /**\r\n     * Tempo (ticks per second) of the song.\r\n     */\r\n    tempo = 10;\r\n    /**\r\n     * Time signature of the song.\r\n     *\r\n     * If this is 3, then the signature is 3/4. This value ranges from 2-8.\r\n     */\r\n    timeSignature = 4;\r\n    /**\r\n     * Amount of milliseconds each tick takes.\r\n     *\r\n     * Getter; updates every reference.\r\n     */\r\n    get timePerTick() {\r\n        return 20 / this.tempo * 50;\r\n    }\r\n    /**\r\n     * Instruments of the song.\r\n     *\r\n     * @see {@linkcode SongInstrument}\r\n     */\r\n    instruments = new SongInstrument();\r\n    /**\r\n     * Layers within the song.\r\n     *\r\n     * @see {@linkcode Layer}\r\n     */\r\n    layers = [];\r\n    /**\r\n     * The `ArrayBuffer` used to load the song.\r\n     */\r\n    arrayBuffer = undefined;\r\n    /**\r\n     * Errors occurred while loading, manipulating, or saving the nbs file.\r\n     *\r\n     * Returns an empty array if no errors occurred.\r\n     */\r\n    errors = [];\r\n    constructor() {\r\n        Object.defineProperties(this.stats, {\r\n            \"hasSolo\": {\r\n                \"get\": () => {\r\n                    let found = false;\r\n                    // Iterate each layer\r\n                    for (const layer of this.layers) {\r\n                        // Solo layer found\r\n                        if (layer.isSolo) {\r\n                            found = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    return found;\r\n                }\r\n            },\r\n            \"duration\": {\r\n                \"get\": () => {\r\n                    return this.length * this.timePerTick;\r\n                }\r\n            },\r\n            \"lastMeasure\": {\r\n                \"get\": () => {\r\n                    return Math.ceil(this.length / this.timeSignature) * this.timeSignature;\r\n                }\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Create and add a new blank layer to the song.\r\n     */\r\n    createLayer() {\r\n        const layer = new (getLayerClass())(this.layers.length + 1);\r\n        this.layers.push(layer);\r\n        return layer;\r\n    }\r\n    /**\r\n     * Set the note at a tick.\r\n     *\r\n     * @param tick Tick to set the note\r\n     * @param layer Layer to set the note on\r\n     * @param note Note to set\r\n     */\r\n    setNote(tick, layer, note) {\r\n        this.expand(tick);\r\n        layer.setNote(tick, note);\r\n    }\r\n    /**\r\n     * Create and add a note to a tick.\r\n     *\r\n     * @param layer Layer to add the note to\r\n     * @param tick Tick to set the note\r\n     * @param instrument The note's instrument\r\n     * @param options Options for the note\r\n     */\r\n    addNote(layer, tick, instrument = 0, options = defaultNoteOptions) {\r\n        this.expand(tick);\r\n        // Construct the note\r\n        return layer.addNote(tick, instrument, options);\r\n    }\r\n    /**\r\n     * Delete a layer from the song.\r\n     *\r\n     * @param layer Layer to delete.\r\n     */\r\n    deleteLayer(layer) {\r\n        this.layers.splice(this.layers.indexOf(layer), 1);\r\n    }\r\n    /**\r\n     * Expand the song if required.\r\n     *\r\n     * @param tick Tick that is being added\r\n     */\r\n    expand(tick) {\r\n        // Expand the song if required\r\n        if (tick + 1 > this.length) {\r\n            this.length = tick + 1;\r\n        }\r\n    }\r\n    /**\r\n     * Generate and return an ArrayBuffer from this song.\r\n     *\r\n     * @return Generated ArrayBuffer\r\n     * Returns an empty ArrayBuffer if an error occurred\r\n     */\r\n    toArrayBuffer() {\r\n        return toArrayBuffer(this);\r\n    }\r\n}\r\n","references":["/workspace/NBS.js/src/nbs/file/toArrayBuffer.ts","/workspace/NBS.js/src/nbs/Layer.ts","/workspace/NBS.js/src/util/util.ts","/workspace/NBS.js/src/nbs/interfaces/song/SongMeta.ts","/workspace/NBS.js/src/nbs/interfaces/song/SongStats.ts","/workspace/NBS.js/src/nbs/interfaces/song/SongLoopOptions.ts","/workspace/NBS.js/src/nbs/interfaces/song/SongAutosaveOptions.ts","/workspace/NBS.js/src/nbs/interfaces/note/NoteOptions.ts","/workspace/NBS.js/src/nbs/Note.ts","/workspace/NBS.js/src/nbs/instrument/SongInstrument.ts","/workspace/NBS.js/src/nbs/instrument/Instrument.ts"],"dts":{"name":"/workspace/NBS.js/node_modules/.cache/rollup-plugin-typescript2/placeholder/nbs/Song.d.ts","writeByteOrderMark":false,"text":"import Layer from \"./Layer\";\r\nimport NoteOptions from \"./interfaces/note/NoteOptions\";\r\nimport Note from \"./Note\";\r\nimport SongInstrument from \"./instrument/SongInstrument\";\r\nimport Instrument from \"./instrument/Instrument\";\r\n/**\r\n * Represents a full NBS song file.\r\n *\r\n * Supports reading, writing, and manipulation.\r\n *\r\n * @example\r\n * ```js\r\n * const fs = require(\"fs\");\r\n * const { Song, Note, Instrument } = require(\"@encode42/nbs.js\");\r\n *\r\n * // Create a new song\r\n * const song = new Song();\r\n * song.meta.name = \"Triumph\";\r\n * song.meta.author = \"Encode42\";\r\n * song.tempo = 20;\r\n *\r\n * // Create 3 layers for 3 instruments\r\n * for (let layerCount = 0; layerCount < 3; layerCount++) {\r\n *     const instrument = Instrument.builtIn[layerCount];\r\n *\r\n *     // Create a layer for the instrument\r\n *     const layer = song.createLayer();\r\n *     layer.meta.name = instrument.meta.name;\r\n *\r\n *     // Notes that will be placed\r\n *     const notes = [\r\n *         new Note(instrument, { \"key\": 40 }),\r\n *         new Note(instrument, { \"key\": 45 }),\r\n *         new Note(instrument, { \"key\": 50 }),\r\n *         new Note(instrument, { \"key\": 45 }),\r\n *         new Note(instrument, { \"key\": 57 })\r\n *     ];\r\n *\r\n *     // Place the notes\r\n *     for (let i = 0; i < notes.length; i++) {\r\n *         song.setNote(i * 4, layer, notes[i]);\r\n *     }\r\n * }\r\n *\r\n * // Write the song\r\n * fs.writeFileSync(\"song.nbs\", Buffer.from(song.toArrayBuffer()));\r\n * ```\r\n */\r\nexport default class Song {\r\n    /**\r\n     * Length of the song in ticks.\r\n     */\r\n    length: number;\r\n    /**\r\n     * Version of NBS the song has been saved to.\r\n     *\r\n     * @see https://opennbs.org/nbs\r\n     */\r\n    nbsVersion: number;\r\n    /**\r\n     * Meta information for the song.\r\n     *\r\n     * @see {@linkcode SongMeta}\r\n     */\r\n    meta: {\r\n        name: string;\r\n        author: string;\r\n        originalAuthor: string;\r\n        description: string;\r\n        importName: string;\r\n    };\r\n    /**\r\n     * Looping options for the song.\r\n     *\r\n     * @see {@linkcode SongLoopOptions}\r\n     */\r\n    loop: {\r\n        enabled: boolean;\r\n        startTick: number;\r\n        totalLoops: number;\r\n    };\r\n    /**\r\n     * Auto-save options for the song.\r\n     *\r\n     * @see {@linkcode SongAutosaveOptions}\r\n     */\r\n    autosave: {\r\n        enabled: boolean;\r\n        interval: number;\r\n    };\r\n    /**\r\n     * Statistics for the song.\r\n     *\r\n     * @see {@linkcode SongStats}\r\n     */\r\n    stats: {\r\n        minutesSpent: number;\r\n        leftClicks: number;\r\n        rightClicks: number;\r\n        blocksAdded: number;\r\n        blocksRemoved: number;\r\n        duration?: number | undefined;\r\n        lastMeasure?: number | undefined;\r\n        hasSolo?: boolean | undefined;\r\n    };\r\n    /**\r\n     * Tempo (ticks per second) of the song.\r\n     */\r\n    tempo: number;\r\n    /**\r\n     * Time signature of the song.\r\n     *\r\n     * If this is 3, then the signature is 3/4. This value ranges from 2-8.\r\n     */\r\n    timeSignature: number;\r\n    /**\r\n     * Amount of milliseconds each tick takes.\r\n     *\r\n     * Getter; updates every reference.\r\n     */\r\n    get timePerTick(): number;\r\n    /**\r\n     * Instruments of the song.\r\n     *\r\n     * @see {@linkcode SongInstrument}\r\n     */\r\n    instruments: SongInstrument;\r\n    /**\r\n     * Layers within the song.\r\n     *\r\n     * @see {@linkcode Layer}\r\n     */\r\n    layers: Layer[];\r\n    /**\r\n     * The `ArrayBuffer` used to load the song.\r\n     */\r\n    arrayBuffer: ArrayBuffer | undefined;\r\n    /**\r\n     * Errors occurred while loading, manipulating, or saving the nbs file.\r\n     *\r\n     * Returns an empty array if no errors occurred.\r\n     */\r\n    errors: string[];\r\n    constructor();\r\n    /**\r\n     * Create and add a new blank layer to the song.\r\n     */\r\n    createLayer(): Layer;\r\n    /**\r\n     * Set the note at a tick.\r\n     *\r\n     * @param tick Tick to set the note\r\n     * @param layer Layer to set the note on\r\n     * @param note Note to set\r\n     */\r\n    setNote(tick: number, layer: Layer, note: Note): void;\r\n    /**\r\n     * Create and add a note to a tick.\r\n     *\r\n     * @param layer Layer to add the note to\r\n     * @param tick Tick to set the note\r\n     * @param instrument The note's instrument\r\n     * @param options Options for the note\r\n     */\r\n    addNote(layer: Layer, tick: number, instrument?: Instrument | number, options?: NoteOptions): Note;\r\n    /**\r\n     * Delete a layer from the song.\r\n     *\r\n     * @param layer Layer to delete.\r\n     */\r\n    deleteLayer(layer: Layer): void;\r\n    /**\r\n     * Expand the song if required.\r\n     *\r\n     * @param tick Tick that is being added\r\n     */\r\n    private expand;\r\n    /**\r\n     * Generate and return an ArrayBuffer from this song.\r\n     *\r\n     * @return Generated ArrayBuffer\r\n     * Returns an empty ArrayBuffer if an error occurred\r\n     */\r\n    toArrayBuffer(): ArrayBuffer;\r\n}\r\n"}}
