{"code":"import { BufferReader, getInstrumentClass } from \"../../util/util\";\r\nimport Song from \"../Song\";\r\n/**\r\n * Parse and return a song from a file array buffer.\r\n *\r\n * @param arrayBuffer ArrayBuffer to parse from\r\n * @return Parsed song\r\n * Returns an empty song if an error occurred\r\n */\r\nexport default function fromArrayBuffer(arrayBuffer) {\r\n    const song = new Song();\r\n    try {\r\n        const reader = new BufferReader(arrayBuffer);\r\n        let size = reader.readShort(); // Read song size\r\n        // Check if NBS file is ONBS versioned\r\n        if (size === 0) {\r\n            song.nbsVersion = reader.readByte(); // Read NBS version\r\n            song.instruments.firstCustomIndex = reader.readByte(); // Read first custom instrument\r\n            if (song.nbsVersion >= 3) {\r\n                size = reader.readShort(); // Read real song size\r\n            }\r\n        }\r\n        const totalLayers = reader.readShort(); // Read total amount of layers\r\n        song.meta.name = reader.readString(); // Read song name\r\n        song.meta.author = reader.readString(); // Read song author\r\n        song.meta.originalAuthor = reader.readString(); // Read song original author\r\n        song.meta.description = reader.readString(); // Read song description\r\n        song.tempo = reader.readShort() / 100; // Read song tempo\r\n        song.autosave.enabled = Boolean(reader.readByte()); // Read song auto-save status\r\n        song.autosave.interval = reader.readByte(); // Read song auto-save interval\r\n        song.timeSignature = reader.readByte(); // Read song time signature\r\n        song.stats.minutesSpent = reader.readInt(); // Read minutes spent in song\r\n        song.stats.leftClicks = reader.readInt(); // Read left-clicks on song\r\n        song.stats.rightClicks = reader.readInt(); // Read right-clicks on song\r\n        song.stats.blocksAdded = reader.readInt(); // Read total blocks added to song\r\n        song.stats.blocksRemoved = reader.readInt(); // Read total blocks removed from song\r\n        song.meta.importName = reader.readString(); // Read imported MiDi/schematic file name\r\n        if (song.nbsVersion >= 4) {\r\n            song.loop.enabled = Boolean(reader.readByte()); // Read loop status\r\n            song.loop.totalLoops = reader.readByte(); // Read maximum loop count\r\n            song.loop.startTick = reader.readShort(); // Read loop start tick\r\n        }\r\n        // Read layer and note data\r\n        const rawNotes = [];\r\n        let tick = -1;\r\n        while (true) {\r\n            // Jump to the next tick\r\n            const jumpTicks = reader.readShort(); // Read amount of ticks to jump\r\n            if (jumpTicks === 0) {\r\n                break;\r\n            }\r\n            tick += jumpTicks;\r\n            let layer = -1;\r\n            while (true) {\r\n                // Jump to the next layer\r\n                const jumpLayers = reader.readShort(); // Read amount of layers to jump\r\n                if (jumpLayers === 0) {\r\n                    break;\r\n                }\r\n                layer += jumpLayers;\r\n                // Get note at tick\r\n                const instrument = reader.readByte(); // Read instrument of note\r\n                const key = reader.readByte(); // Read key of note\r\n                let velocity = 100;\r\n                let panning = 100;\r\n                let pitch = 0;\r\n                if (song.nbsVersion >= 4) {\r\n                    velocity = reader.readByte(); // Read velocity of note\r\n                    panning = reader.readUnsingedByte() - 100; // Read panning of note\r\n                    pitch = reader.readShort(); // Read pitch of note\r\n                }\r\n                // Push the note data to raw notes array\r\n                rawNotes.push({\r\n                    \"instrument\": instrument,\r\n                    \"key\": key,\r\n                    \"velocity\": velocity,\r\n                    \"panning\": panning,\r\n                    \"pitch\": pitch,\r\n                    \"layer\": layer,\r\n                    \"tick\": tick\r\n                });\r\n            }\r\n        }\r\n        // Guess song size for ONBS versions without size byte\r\n        if (song.nbsVersion > 0 && song.nbsVersion < 3) {\r\n            size = tick;\r\n        }\r\n        song.length = size;\r\n        // Add layers to song\r\n        if (arrayBuffer.byteLength > reader.nextByte) {\r\n            for (let i = 0; i < totalLayers; i++) {\r\n                const layer = song.createLayer();\r\n                layer.meta.name = reader.readString(); // Read layer name\r\n                if (song.nbsVersion >= 4) {\r\n                    const lock = reader.readByte(); // Read layer lock status\r\n                    // Layer is locked\r\n                    if (lock === 1) {\r\n                        layer.isLocked = true;\r\n                    }\r\n                    // Layer is solo\r\n                    if (lock === 2) {\r\n                        layer.isSolo = true;\r\n                    }\r\n                }\r\n                layer.volume = reader.readByte(); // Read layer velocity\r\n                let panning = 0;\r\n                if (song.nbsVersion >= 2) {\r\n                    panning = reader.readUnsingedByte() - 100; // Read layer panning\r\n                }\r\n                layer.stereo = panning;\r\n            }\r\n        }\r\n        // Parse custom instruments\r\n        const customInstruments = reader.readByte(); // Read number of custom instruments\r\n        for (let i = 0; i < customInstruments; i++) {\r\n            song.instruments.loaded.push(new (getInstrumentClass())(reader.readString(), // Read instrument name\r\n            song.instruments.loaded.length, {\r\n                \"audioSrc\": reader.readString(),\r\n                \"key\": reader.readByte(),\r\n                \"pressKey\": Boolean(reader.readByte()) // Read press key status\r\n            }));\r\n        }\r\n        // Parse notes\r\n        for (const rawNote of rawNotes) {\r\n            // Create layer if non-existent\r\n            if (rawNote.layer >= song.layers.length) {\r\n                song.createLayer();\r\n            }\r\n            // Add note to layer\r\n            const layer = song.layers[rawNote.layer];\r\n            song.addNote(layer, rawNote.tick, rawNote.instrument, rawNote);\r\n        }\r\n        song.arrayBuffer = arrayBuffer;\r\n    }\r\n    catch (e) {\r\n        song.errors.push(String(e));\r\n    }\r\n    return song;\r\n}\r\n","references":["/workspace/NBS.js/src/util/util.ts","/workspace/NBS.js/src/nbs/Song.ts"],"dts":{"name":"/workspace/NBS.js/node_modules/.cache/rollup-plugin-typescript2/placeholder/nbs/file/fromArrayBuffer.d.ts","writeByteOrderMark":false,"text":"import Song from \"../Song\";\r\n/**\r\n * Parse and return a song from a file array buffer.\r\n *\r\n * @param arrayBuffer ArrayBuffer to parse from\r\n * @return Parsed song\r\n * Returns an empty song if an error occurred\r\n */\r\nexport default function fromArrayBuffer(arrayBuffer: ArrayBuffer): Song;\r\n"}}
